<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JA Trader Panel</title>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <style>
    body { background: #111822; color: white; font-family: Arial, sans-serif; padding: 20px; }
    input,{ padding: 6px 10px; margin: 5px; }
    button { padding: 10px 10px; margin: 5px; color:#111; background-color:lightgreen;border-radius:10px;cursor:pointer;   }
    #chart { background: white; border-radius: 10px; margin-top: 20px; }
    .section { margin-top: 30px; }
    .trade-card { background: #1f2937; padding: 10px; margin: 10px 0; border-radius: 8px; }
    .logout-btn { float: right; margin-top: -35px; }
    .chart-toolbar { margin-top: 10px; }
  </style>
</head>
<body>
  <h1>Welcome, <span id="usernameDisplay"></span></h1>
  <button class="logout-btn" onclick="logout()">Logout</button>

  <p>Market Status: <span id="marketStatus">Checking...</span> | Live Price: ‚Çπ<span id="livePrice">--</span></p>
  <p>Balance: ‚Çπ<span id="balanceDisplay">--</span></p>

  <div>
    <label>Qty:</label><input type="number" id="qty" value="1" min="1">
    <label>TP:</label><input type="number" id="tp">
    <label>SL:</label><input type="number" id="sl">
    <button onclick="placeTrade('buy')">Buy</button>
    <button onclick="placeTrade('sell')">Sell</button>
  </div>

  <div class="section">
    <h2>Withdraw Funds</h2>
    <input id="withdrawAmt" type="number" placeholder="Amount">
    <input id="withdrawPhone" placeholder="WhatsApp Number">
    <button onclick="requestWithdrawal()">Request Withdrawal</button>
    <p style="color:orange">‚ö†Ô∏è 2% withdrawal fee applies. Process in 2 business days.</p>
  </div>

  <div class="chart-toolbar">
    <button onclick="renderChart()">üîÑ Reset Zoom</button>
    <div id="liveTime" style="font-weight:bold; margin-top:10px;"></div>
  </div>
  <div id="chart" style="height: 400px;"></div>

  <div class="section">
    <h2>Open Trades</h2>
    <div id="openTrades"></div>
  </div>

  <div class="section">
    <h2>Withdrawals</h2>
    <div id="withdrawals"></div>
  </div>

  <div class="section">
    <h2>Trade History</h2>
    <div id="tradeHistory"></div>
  </div>

  <div class="section">
    <h2>Performance Summary</h2>
    <p>Total Trades: <span id="totalTrades">0</span> | Wins: <span id="wins">0</span> | Losses: <span id="losses">0</span></p>
  </div>

<script>
/* ---------- CONFIG ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyAr63v10I56cCghOTrGV_KhjQ69HnyaP3Q",
  authDomain: "brokerja-74512.firebaseapp.com",
  databaseURL: "https://brokerja-74512-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "brokerja-74512",
  storageBucket: "brokerja-74512.appspot.com",
  messagingSenderId: "1048821297447",
  appId: "1:1048821297447:web:b8a1e2c43b8ed8333b3902"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------- DOM ELEMENTS (assumes these exist in your HTML) ---------- */
const username = sessionStorage.getItem('username');
if (!username) {
  // If no username in session, redirect to login
  location.href = "login.html";
}
document.getElementById('usernameDisplay').innerText = username;

const livePriceEl = document.getElementById('livePrice');
const marketStatusEl = document.getElementById('marketStatus');
const balanceEl = document.getElementById('balanceDisplay');
const openTradesEl = document.getElementById('openTrades');
const tradeHistoryEl = document.getElementById('tradeHistory');
const totalTradesEl = document.getElementById('totalTrades');
const winsEl = document.getElementById('wins');
const lossesEl = document.getElementById('losses');
const liveTimeEl = document.getElementById('liveTime'); // make sure exists in HTML

/* ---------- Firebase refs ---------- */
const userRef = db.ref('users/' + username);
const tradesRef = db.ref('users/' + username + '/trades');
const balanceRef = db.ref('users/' + username + '/balance');
const priceRef = db.ref('market/currentPrice');
const marketOpenRef = db.ref('market/isOpen');
const candlesRef = db.ref('market/chart');
const withdrawalsRef = db.ref('users/' + username + '/withdrawalRequests');

/* ---------- Chart (Lightweight Charts) ---------- */
const chartContainer = document.getElementById('chart');
const chart = LightweightCharts.createChart(chartContainer, {
  layout: { background: { color: "#0e1621" }, textColor: "#d0d7de" },
  rightPriceScale: { visible: true, borderColor: '#485c7b' },
  timeScale: { timeVisible: true, secondsVisible: true, borderColor: '#485c7b' },
  crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
  grid: { vertLines: { color: '#222a36' }, horzLines: { color: '#222a36' } }
});
const candleSeries = chart.addCandlestickSeries({
  upColor: '#26a69a', downColor: '#ef5350', borderVisible: true, wickUpColor: '#26a69a', wickDownColor: '#ef5350'
});

/* horizontal price lines for trades (store to remove later) */
let entryPriceLine = null;
let tpPriceLine = null;
let slPriceLine = null;

/* chart data store */
let chartData = []; // { time: unixSeconds, open, high, low, close }
const MAX_CANDLES = 200;

/* ---------- Live clock ---------- */
function startClock() {
  if (!liveTimeEl) return;
  function tick() { liveTimeEl.innerText = new Date().toLocaleTimeString('en-IN', { hour12: false }); }
  tick();
  setInterval(tick, 1000);
}
startClock();

/* ---------- Helpers ---------- */
function toLwcTime(ms) { return Math.floor(ms / 1000); } // convert ms timestamp to seconds for lightweight-charts

function applyTradeLines(entry, tp, sl) {
  // remove existing lines
  removeTradeLines();
  if (entry !== undefined && entry !== null) {
    entryPriceLine = candleSeries.createPriceLine({ price: entry, color: '#00aaff', lineWidth: 2, lineStyle: 2, axisLabelVisible: true, title: 'Entry' });
  }
  if (tp !== undefined && tp !== null) {
    tpPriceLine = candleSeries.createPriceLine({ price: tp, color: '#00ff7f', lineWidth: 2, lineStyle: 0, axisLabelVisible: true, title: 'TP' });
  }
  if (sl !== undefined && sl !== null) {
    slPriceLine = candleSeries.createPriceLine({ price: sl, color: '#ff4d4d', lineWidth: 2, lineStyle: 0, axisLabelVisible: true, title: 'SL' });
  }
}
function removeTradeLines() {
  try { if (entryPriceLine) { candleSeries.removePriceLine(entryPriceLine); entryPriceLine = null; } } catch(e){}
  try { if (tpPriceLine) { candleSeries.removePriceLine(tpPriceLine); tpPriceLine = null; } } catch(e){}
  try { if (slPriceLine) { candleSeries.removePriceLine(slPriceLine); slPriceLine = null; } } catch(e){}
}

/* ---------- Candle handling ---------- */
candlesRef.on('value', snap => {
  const raw = snap.val() || {};
  // convert to array and sort by timestamp
  const arr = Object.values(raw)
    .map(c => ({ time: toLwcTime(c.timestamp), open: c.open, high: c.high, low: c.low, close: c.close }))
    .sort((a,b) => a.time - b.time);

  // keep last MAX_CANDLES
  chartData = arr.slice(-MAX_CANDLES);
  // set data to series
  candleSeries.setData(chartData);
  // auto-scroll to latest
  chart.timeScale().scrollToRealTime();
});

/* ---------- Live price & market status ---------- */
priceRef.on('value', snap => {
  const p = parseFloat(snap.val() || 1);
  currentPrice = p;
  if (livePriceEl) livePriceEl.innerText = p.toFixed(2);
  // check open trades for TP/SL closure
  checkAutoCloseTrades(p);
});

marketOpenRef.on('value', snap => {
  const v = snap.val();
  if (marketStatusEl) marketStatusEl.innerText = v ? '‚úÖ Open' : '‚ùå Closed';
});

/* ---------- Balance listener ---------- */
let balance = 0;
balanceRef.on('value', snap => {
  balance = parseFloat(snap.val() || 0);
  if (balanceEl) balanceEl.innerText = (isNaN(balance) ? 0 : balance.toFixed(2));
});

/* ---------- Place trade (called by button) ---------- */
async function placeTrade(side) {
  const qty = parseInt(document.getElementById('qty').value || 0);
  const tp = parseFloat(document.getElementById('tp').value || 0);
  const sl = parseFloat(document.getElementById('sl').value || 0);

  // market open and balance checks
  const marketSnap = await marketOpenRef.once('value');
  if (!marketSnap.val()) return alert('Market is closed');
  if (balance < 5.0) return alert('Insufficient balance to trade.');

  // validate TP/SL relative to entry
  const entry = currentPrice;
  if (side === 'buy') {
    if (!tp || !sl) return alert('Enter TP and SL');
    if (!(tp > entry && sl < entry)) return alert('For BUY: TP must be > entry, SL must be < entry');
  } else {
    if (!tp || !sl) return alert('Enter TP and SL');
    if (!(tp < entry && sl > entry)) return alert('For SELL: TP must be < entry, SL must be > entry');
  }

  // create trade and deduct trade fee ‚Çπ1
  const tradeObj = { side, qty, entry, tp, sl, status: 'open', time: Date.now() };
  const newRef = await tradesRef.push(tradeObj);

  // deduct fee
  await balanceRef.set((parseFloat(balance) || 0) - 1);

  // draw lines for user
  applyTradeLines(entry, tp, sl);
  alert('Trade placed ‚úÖ');
}

/* ---------- Auto-close logic for trades at TP/SL ---------- */
async function checkAutoCloseTrades(latestPrice) {
  // iterate user's open trades and close those hitting TP or SL
  const snap = await tradesRef.once('value');
  const trades = snap.val() || {};
  for (const key in trades) {
    const t = trades[key];
    if (t.status !== 'open') continue;

    let hitTP = false, hitSL = false;
    if (t.side === 'buy') {
      if (t.tp !== undefined && latestPrice >= t.tp) hitTP = true;
      if (t.sl !== undefined && latestPrice <= t.sl) hitSL = true;
    } else { // sell
      if (t.tp !== undefined && latestPrice <= t.tp) hitTP = true;
      if (t.sl !== undefined && latestPrice >= t.sl) hitSL = true;
    }

    if (hitTP || hitSL) {
      // calculate pnl (positive for profit, negative for loss)
      const exitPrice = hitTP ? t.tp : t.sl;
      const pnl = (t.side === 'buy' ? (exitPrice - t.entry) : (t.entry - exitPrice)) * (t.qty || 1);

      // mark closed and update pnl
      await tradesRef.child(key).update({ status: 'closed', pnl: pnl, closedAt: Date.now() });

      // update balance: add pnl (if pnl negative, balance will decrease)
      const currentBalSnap = await balanceRef.once('value');
      const currentBal = parseFloat(currentBalSnap.val() || 0);
      await balanceRef.set(currentBal + pnl);

      // remove trade lines if no other open trades (rebuild lines from remaining opens)
      rebuildTradeLinesFromOpen();
    }
  }

  // refresh local UI
  refreshTradesUI();
}

/* ---------- Manual close (button) ---------- */
async function manualClose(tradeKey) {
  const tSnap = await tradesRef.child(tradeKey).once('value');
  const t = tSnap.val();
  if (!t || t.status !== 'open') return alert('Trade not open');

  // use currentPrice as exit
  const exitPrice = currentPrice;
  const pnl = (t.side === 'buy' ? (exitPrice - t.entry) : (t.entry - exitPrice)) * (t.qty || 1);
  await tradesRef.child(tradeKey).update({ status: 'closed', pnl, closedAt: Date.now() });

  // update balance
  const currentBalSnap = await balanceRef.once('value');
  const currentBal = parseFloat(currentBalSnap.val() || 0);
  await balanceRef.set(currentBal + pnl);

  rebuildTradeLinesFromOpen();
  refreshTradesUI();
  alert('Trade manually closed ‚úÖ');
}

/* ---------- Rebuild trade lines from remaining open trades ---------- */
async function rebuildTradeLinesFromOpen() {
  const snap = await tradesRef.once('value');
  const trades = snap.val() || {};
  // find ONE open trade to display its lines (if multiple open you may want to overlay ‚Äî adjust logic if desired)
  let one = null;
  for (const k in trades) { if (trades[k].status === 'open') { one = trades[k]; break; } }
  if (one) applyTradeLines(one.entry, one.tp, one.sl);
  else removeTradeLines();
}

/* ---------- UI refresh for trades & history ---------- */
async function refreshTradesUI() {
  const snap = await tradesRef.once('value');
  const trades = snap.val() || {};

  openTradesEl.innerHTML = '';
  tradeHistoryEl.innerHTML = '';

  let wins = 0, losses = 0, total = 0;
  for (const key in trades) {
    const t = trades[key];
    if (t.status === 'open') {
      const pnlNow = ((t.side === 'buy' ? currentPrice - t.entry : t.entry - currentPrice) * (t.qty || 1)).toFixed(2);
      const div = document.createElement('div');
      div.className = 'trade-card';
      div.innerHTML = `
        <strong>${t.side.toUpperCase()}</strong> | Entry: ‚Çπ${t.entry.toFixed(2)} | Qty: ${t.qty || 1}<br>
        TP: ‚Çπ${t.tp} | SL: ‚Çπ${t.sl}<br>
        Live P&L: ‚Çπ${pnlNow} <br>
        <button onclick="manualClose('${key}')">Close</button>
      `;
      openTradesEl.appendChild(div);
    } else {
      total++;
      if ((t.pnl || 0) > 0) wins++; else losses++;
      const div = document.createElement('div');
      div.className = 'trade-card';
      div.innerHTML = `
        <strong>${t.side.toUpperCase()}</strong> | Entry: ‚Çπ${t.entry.toFixed(2)} | Qty: ${t.qty || 1}<br>
        TP: ‚Çπ${t.tp} | SL: ‚Çπ${t.sl}<br>
        Result P&L: ‚Çπ${(t.pnl || 0).toFixed(2)}
      `;
      tradeHistoryEl.appendChild(div);
    }
  }
  totalTradesEl.innerText = total;
  winsEl.innerText = wins;
  lossesEl.innerText = losses;
}

/* ---------- Withdrawal request ---------- */
async function requestWithdrawal() {
  const amount = parseFloat(document.getElementById('withdrawAmt').value || 0);
  const phone = document.getElementById('withdrawPhone').value || '';
  if (!amount || !phone) return alert('Fill amount and WhatsApp number');
  // push request under user's node
  await withdrawalsRef.push({ amount, contact: phone, status: 'pending', timestamp: Date.now() });
  alert('Withdrawal request sent. Process: 2 business days. 2% fee will apply.');
}

/* ---------- Fullscreen helper ---------- */
function toggleFullscreen() {
  const el = document.getElementById('chart');
  if (!document.fullscreenElement) return el.requestFullscreen?.();
  document.exitFullscreen?.();
}

/* ---------- Initial UI boot and listeners ---------- */
(async function init() {
  // attach global functions for buttons used inline in HTML (if any)
  window.placeTrade = placeTrade;
  window.manualClose = manualClose;
  window.requestWithdrawal = requestWithdrawal;
  window.toggleFullscreen = toggleFullscreen;

  // refresh UI whenever trades update
  tradesRef.on('value', snap => {
    refreshTradesUI();
    // rebuild lines if needed
    rebuildTradeLinesFromOpen();
  });

  // initial refresh
  refreshTradesUI();
  rebuildTradeLinesFromOpen();
})();
</script>
</body>

</html>













